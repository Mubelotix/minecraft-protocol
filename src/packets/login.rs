//! For general information about login, see [the wiki](https://wiki.vg/Protocol#Login).

use crate::*;

#[derive(Debug, MinecraftPacketPart)]
#[discriminant(VarInt)]
pub enum ClientboundPacket<'a> {
    Disconnect {
        reason: Chat<'a>,
    },

    /// See [Protocol Encryption](https://wiki.vg/Protocol_Encryption) for details.
    ///
    /// *Request for [ServerboundPacket::EncryptionResponse]*
    EncryptionRequest {
        /// Appears to be empty
        server_id: &'a str,
        /// The server's public key in bytes
        public_key: Array<'a, u8, VarInt>,
        /// A sequence of random bytes generated by the server
        verify_token: Array<'a, u8, VarInt>,
    },

    /// This packet switches the connection state to [ConnectionState::Play].
    ///
    /// **Warning**: The (notchian) server might take a bit to fully transition to the `Play` state, so it's recommended to wait before sending `Play` packets, either by setting a timeout, or waiting for Play packets from the server (usually [PlayerInfo](super::play_clientbound::ClientboundPacket::PlayerInfo)).
    /// The notchian client doesn't send any (non-keep alive) packets until the next tick/time update packet.
    LoginSuccess {
        uuid: UUID,
        username: &'a str,
    },

    /// Enables compression.
    /// If compression is enabled, all following packets are encoded in the compressed packet format.
    /// Negative or zero values will disable compression, meaning the packet format should remain in the uncompressed packet format.
    /// However, this packet is entirely optional, and if not sent, compression will also not be enabled (the notchian server does not send the packet when compression is disabled).
    SetCompression {
        /// Maximum size of a packet before it is compressed
        threshold: VarInt,
    },

    /// Used to implement a custom handshaking flow.
    /// Unlike plugin messages in "play" mode, these messages follow a lock-step request/response scheme, where the client is expected to respond to a request indicating whether it understood. The notchian client always responds that it hasn't understood, and sends an empty payload.
    ///
    /// *Request for [ServerboundPacket::LoginPluginResponse]*
    LoginPluginRequest {
        /// Generated by the server - should be unique to the connection
        message_id: VarInt,
        /// Name of the plugin channel used to send the data
        channel: Identifier<'a>,
        /// Any data, depending on the channel
        data: RawBytes<'a>,
    },
}

#[derive(Debug, MinecraftPacketPart)]
#[discriminant(VarInt)]
pub enum ServerboundPacket<'a> {
    LoginStart {
        /// Player's Username
        username: &'a str,
        /// The UUID of the player logging in. Unused by the Notchian server.
        player_uuid: UUID,
    },

    /// See [Protocol Encryption](https://wiki.vg/Protocol_Encryption) for details.
    ///
    /// *Response for [ClientboundPacket::EncryptionRequest]*
    EncryptionResponse {
        /// Shared Secret value, encrypted with the [server's public key](ClientboundPacket::EncryptionRequest::public_key).
        shared_secret: Array<'a, u8, VarInt>,
        /// Verify Token value, encrypted with the `shared_secret`.
        verify_token: Array<'a, u8, VarInt>,
    },

    /// *Response for [ClientboundPacket::LoginPluginRequest]*
    LoginPluginResponse {
        /// Should match ID from server.
        message_id: VarInt,
        /// `Some(data)` if the client understands the [request](ClientboundPacket::LoginPluginRequest), `None` otherwise
        data: Option<RawBytes<'a>>,
    },

    LoginAcknowledged,
}
